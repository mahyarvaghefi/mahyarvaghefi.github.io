<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HUE ‚Äî Homophily-based User Embedding | Dr. Mahyar Vaghefi</title>
    <meta name="description" content="Documentation and practical guide for HUE (Homophily-based User Embedding) ‚Äî a node embedding method for social networks. Published in JAIS 2021. By Dr. Mahyar S. Vaghefi.">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Serif+4:ital,opsz,wght@0,8..60,300;0,8..60,400;0,8..60,600;0,8..60,700;1,8..60,400&family=DM+Sans:ital,opsz,wght@0,9..40,300;0,9..40,400;0,9..40,500;0,9..40,600;1,9..40,400&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #FAFAF8;
            --bg-card: #FFFFFF;
            --text-primary: #1A1A1A;
            --text-secondary: #555555;
            --text-muted: #888888;
            --accent: #0C4A6E;
            --accent-light: #E0F2FE;
            --accent-hover: #075985;
            --border: #E5E5E3;
            --border-light: #F0F0EE;
            --tag-bg: #F3F4F6;
            --tag-text: #374151;
            --shadow-sm: 0 1px 2px rgba(0,0,0,0.04);
            --shadow-md: 0 4px 12px rgba(0,0,0,0.06);
            --radius: 10px;
            --serif: 'Source Serif 4', Georgia, serif;
            --sans: 'DM Sans', -apple-system, sans-serif;
            --mono: 'JetBrains Mono', monospace;
            --warn: #92400E;
            --warn-bg: #FFFBEB;
            --warn-border: #FDE68A;
            --tip-bg: #F0FDF4;
            --tip-border: #86EFAC;
            --tip-text: #166534;
        }

        *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
        html { scroll-behavior: smooth; font-size: 16px; }

        body {
            font-family: var(--sans);
            background: var(--bg);
            color: var(--text-primary);
            line-height: 1.7;
            -webkit-font-smoothing: antialiased;
        }

        .container {
            max-width: 820px;
            margin: 0 auto;
            padding: 2rem 1.5rem 4rem;
        }

        .back-link {
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            color: var(--accent);
            text-decoration: none;
            font-size: 0.85rem;
            font-weight: 500;
            margin-bottom: 2.5rem;
            transition: gap 0.2s;
        }
        .back-link:hover { gap: 0.6rem; }

        .guide-header {
            margin-bottom: 2.5rem;
            padding-bottom: 2rem;
            border-bottom: 1px solid var(--border);
        }
        .guide-header .breadcrumb {
            font-size: 0.78rem;
            color: var(--text-muted);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.06em;
            margin-bottom: 0.75rem;
        }
        .guide-header h1 {
            font-family: var(--serif);
            font-size: 2.2rem;
            font-weight: 700;
            line-height: 1.2;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
        }
        .guide-header .subtitle {
            font-size: 1.05rem;
            color: var(--text-secondary);
            margin-bottom: 1rem;
        }
        .guide-header .meta {
            display: flex;
            gap: 1.25rem;
            flex-wrap: wrap;
            font-size: 0.82rem;
            color: var(--text-muted);
        }
        .guide-header .meta span {
            display: inline-flex;
            align-items: center;
            gap: 0.35rem;
        }
        .guide-header .meta a {
            color: var(--accent);
            text-decoration: none;
        }
        .guide-header .meta a:hover { text-decoration: underline; }

        .badge-row {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1rem 0 0.5rem;
        }
        .badge {
            display: inline-flex;
            align-items: center;
            gap: 0.3rem;
            padding: 0.25rem 0.65rem;
            border-radius: 20px;
            font-size: 0.75rem;
            font-weight: 500;
            border: 1px solid var(--border);
            background: var(--bg-card);
        }
        .badge.green { border-color: #16a34a; color: #15803d; background: #f0fdf4; }
        .badge.blue { border-color: var(--accent); color: var(--accent); background: var(--accent-light); }

        .section-title {
            font-family: var(--serif);
            font-size: 1.5rem;
            font-weight: 600;
            letter-spacing: -0.02em;
            margin: 3rem 0 1.25rem;
            padding-bottom: 0.6rem;
            border-bottom: 2px solid var(--border);
        }
        .section-title:first-of-type { margin-top: 0; }

        p { margin-bottom: 1rem; font-size: 0.95rem; }
        p:last-child { margin-bottom: 0; }
        h3.sub { font-size: 1rem; font-weight: 600; margin: 1.5rem 0 1rem; }

        .callout {
            border-radius: var(--radius);
            padding: 1.25rem 1.5rem;
            margin: 1.5rem 0;
            border: 1px solid var(--border);
        }
        .callout-title {
            font-size: 0.85rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.04em;
            margin-bottom: 0.6rem;
            display: flex;
            align-items: center;
            gap: 0.4rem;
        }
        .callout p { font-size: 0.9rem; color: var(--text-secondary); }
        .callout.concept { background: var(--accent-light); border-color: #BAE6FD; }
        .callout.concept .callout-title { color: var(--accent); }
        .callout.tip { background: var(--tip-bg); border-color: var(--tip-border); }
        .callout.tip .callout-title { color: var(--tip-text); }
        .callout.warning { background: var(--warn-bg); border-color: var(--warn-border); }
        .callout.warning .callout-title { color: var(--warn); }

        .table-wrapper {
            overflow-x: auto;
            margin: 1.5rem 0;
            border: 1px solid var(--border);
            border-radius: var(--radius);
        }
        table { width: 100%; border-collapse: collapse; font-size: 0.88rem; }
        thead { background: var(--accent); }
        th {
            padding: 0.75rem 1rem;
            text-align: left;
            font-weight: 600;
            color: #fff;
            font-size: 0.82rem;
            letter-spacing: 0.02em;
        }
        td {
            padding: 0.7rem 1rem;
            border-top: 1px solid var(--border-light);
            color: var(--text-primary);
        }
        tbody tr:nth-child(even) { background: #FAFAF8; }
        td code, p code {
            font-family: var(--mono);
            font-size: 0.82rem;
            background: var(--tag-bg);
            padding: 0.15rem 0.4rem;
            border-radius: 4px;
        }

        .code-block {
            background: #1E293B;
            border-radius: var(--radius);
            padding: 1.5rem;
            margin: 1.5rem 0;
            overflow-x: auto;
            font-family: var(--mono);
            font-size: 0.84rem;
            line-height: 1.8;
            color: #E2E8F0;
        }
        .code-block .comment { color: #64748B; }
        .code-block .output { color: #94A3B8; }

        .compare-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin: 1.5rem 0;
        }
        .compare-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1.25rem;
        }
        .compare-card h4 { font-size: 0.88rem; font-weight: 600; margin-bottom: 0.4rem; }
        .compare-card p { font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0; }

        .visual-example {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1.5rem;
            margin: 1.5rem 0;
        }
        .visual-example .label {
            font-size: 0.78rem;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.04em;
            margin-bottom: 1rem;
        }

        /* Steps (algorithm) */
        .steps { counter-reset: step; margin: 1.5rem 0; }
        .step {
            position: relative;
            padding: 0.9rem 0 0.9rem 3.5rem;
            counter-increment: step;
            border-left: 2px solid var(--border);
        }
        .step::before {
            content: counter(step);
            position: absolute; left: -15px; top: 0.85rem;
            width: 28px; height: 28px; border-radius: 50%;
            background: var(--accent); color: #fff;
            font-weight: 600; font-size: 0.78rem;
            display: flex; align-items: center; justify-content: center;
        }
        .step:last-child { border-left-color: transparent; }
        .step h4 { font-size: 0.9rem; font-weight: 600; margin-bottom: 0.15rem; }
        .step p { font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 0; }

        /* Formula */
        .formula-card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 1.5rem;
            text-align: center;
            margin: 1.5rem 0;
        }
        .formula-card .formula {
            font-family: var(--serif);
            font-size: 1rem;
            font-style: italic;
            margin-bottom: 0.5rem;
            line-height: 1.9;
        }
        .formula-card .caption { font-size: 0.8rem; color: var(--text-muted); margin-bottom: 0; }

        /* Citation */
        .citation-block {
            background: var(--accent-light);
            border-left: 3px solid var(--accent);
            border-radius: 0 var(--radius) var(--radius) 0;
            padding: 1.25rem 1.5rem;
            margin: 1.5rem 0;
            font-size: 0.9rem;
            color: var(--text-secondary);
        }
        .citation-block strong { color: var(--accent); }
        .citation-block a { color: var(--accent); text-decoration: none; }
        .citation-block a:hover { text-decoration: underline; }

        .bibtex-block {
            background: #1E293B;
            color: #E2E8F0;
            padding: 1.25rem 1.5rem;
            border-radius: var(--radius);
            font-family: var(--mono);
            font-size: 0.72rem;
            line-height: 1.6;
            overflow-x: auto;
            white-space: pre;
            margin: 1rem 0;
        }

        /* Takeaways */
        .takeaways {
            background: var(--accent);
            border-radius: var(--radius);
            padding: 2rem;
            margin: 2.5rem 0;
            color: #fff;
        }
        .takeaways h3 {
            font-family: var(--serif);
            font-size: 1.15rem;
            font-weight: 600;
            margin-bottom: 1.25rem;
        }
        .takeaway-item {
            display: flex;
            align-items: flex-start;
            gap: 0.6rem;
            margin-bottom: 0.85rem;
            font-size: 0.9rem;
            line-height: 1.6;
        }
        .takeaway-item:last-child { margin-bottom: 0; }
        .takeaway-item .check {
            color: #6EE7B7;
            font-size: 0.85rem;
            flex-shrink: 0;
            margin-top: 0.15rem;
        }
        .takeaway-item code { background: rgba(255,255,255,0.15); color: #fff; }

        .guide-footer {
            margin-top: 3rem;
            padding-top: 2rem;
            border-top: 1px solid var(--border);
            text-align: center;
            font-size: 0.82rem;
            color: var(--text-muted);
        }
        .guide-footer a { color: var(--accent); text-decoration: none; }
        .guide-footer a:hover { text-decoration: underline; }

        @media (max-width: 640px) {
            .container { padding: 1.25rem 1rem 3rem; }
            .guide-header h1 { font-size: 1.65rem; }
            .section-title { font-size: 1.25rem; }
            .compare-grid { grid-template-columns: 1fr; }
            .step { padding-left: 2.5rem; }
        }
    </style>
</head>
<body>
    <div class="container">

        <a href="../index.html" class="back-link">
            <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M19 12H5M12 19l-7-7 7-7"/></svg>
            Back to Home
        </a>

        <div class="guide-header">
            <p class="breadcrumb">Code &amp; Software &mdash; Documentation</p>
            <h1>HUE</h1>
            <p class="subtitle">Homophily-based User Embedding for Social Networks</p>
            <div class="badge-row">
                <span class="badge green">&#10003; Published in JAIS 2021</span>
                <span class="badge blue">Python 3.8+</span>
                <span class="badge">MIT License</span>
            </div>
            <div class="meta">
                <span>
                    <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M20 21v-2a4 4 0 00-4-4H8a4 4 0 00-4 4v2"/><circle cx="12" cy="7" r="4"/></svg>
                    M. S. Vaghefi &amp; D. Nazareth
                </span>
                <span>
                    <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 00-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0020 4.77 5.07 5.07 0 0019.91 1S18.73.65 16 2.48a13.38 13.38 0 00-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 005 4.77a5.44 5.44 0 00-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 009 18.13V22"/></svg>
                    <a href="https://github.com/mahyarvaghefi/HUE" target="_blank">View on GitHub</a>
                </span>
                <span>
                    <svg width="14" height="14" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                    <a href="https://doi.org/10.17705/1jais.00711" target="_blank">Read the Paper</a>
                </span>
            </div>
        </div>

        <!-- ‚îÄ‚îÄ Overview ‚îÄ‚îÄ -->
        <h2 class="section-title">Overview</h2>

        <p>HUE (Homophily-based User Embedding) is a node embedding method for social network graphs. Unlike black-box approaches like DeepWalk or Node2Vec, HUE produces <strong>interpretable</strong> embeddings ‚Äî each dimension corresponds to an identifiable community of interest (e.g., news, sports, fashion).</p>

        <div class="callout concept">
            <p class="callout-title">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4M12 8h.01"/></svg>
                The Big Idea
            </p>
            <p>In social networks, <strong>similar people follow similar things</strong> ‚Äî that's homophily. HUE exploits this: if two social pages have overlapping followers <em>who also connect with each other</em>, those pages serve a similar interest. By clustering pages this way, HUE discovers communities and maps every user to their level of engagement with each one.</p>
        </div>

        <h3 class="sub">The Extended Bipartite Graph</h3>

        <p>The central structure in HUE is the <strong>extended bipartite graph</strong>. In a social network like Twitter, there are two types of accounts:</p>

        <div class="compare-grid">
            <div class="compare-card">
                <h4>üìÑ Social Pages (Cores)</h4>
                <p>Public accounts like @nytimes, @espn, @vogue that represent specific topics. These are the <strong>core vertices</strong> ‚Äî typically accounts with many followers.</p>
            </div>
            <div class="compare-card">
                <h4>üë§ Regular Users</h4>
                <p>Ordinary users who follow some set of social pages and are also connected to each other through friendships or mutual follows.</p>
            </div>
        </div>

        <p>This gives rise to <strong>two separate networks</strong> that HUE uses together:</p>

        <div class="compare-grid">
            <div class="compare-card">
                <h4>1. Bipartite Network</h4>
                <p><strong>Users ‚Üí Pages.</strong> A directed bipartite graph where rows are users and columns are social pages. Entry (i, j) = 1 means user i follows page j.</p>
            </div>
            <div class="compare-card">
                <h4>2. User-to-User Network</h4>
                <p><strong>Users ‚Üî Users.</strong> The friendship or mutual-follow graph among regular users. Captures the social connections between followers.</p>
            </div>
        </div>

        <p>The bipartite network tells us <em>which pages each user follows</em>, and the user network tells us <em>how those followers are connected to each other</em>. HUE computes the structural similarity between every pair of pages by examining the overlap and internal connectivity of their follower communities. This produces a <strong>weighted graph of pages</strong>, on which modularity-based community detection discovers preference clusters.</p>

        <h3 class="sub">Why HUE?</h3>

        <div class="compare-grid">
            <div class="compare-card">
                <h4>üîç Interpretable</h4>
                <p>Each dimension = a cluster of social pages = a real community of interest. Not a latent black box.</p>
            </div>
            <div class="compare-card">
                <h4>‚ö° Scalable</h4>
                <p>Only processes a fraction of nodes (cores). Tested on 32,000+ users with 10,000 social pages.</p>
            </div>
            <div class="compare-card">
                <h4>üîÑ Incremental</h4>
                <p>New nodes embedded without retraining ‚Äî just measure their connections to existing clusters.</p>
            </div>
            <div class="compare-card">
                <h4>üìä Two Inputs</h4>
                <p>Accepts two separate networks directly (bipartite + user graph), or can extract them from a single graph.</p>
            </div>
        </div>

        <!-- ‚îÄ‚îÄ Installation ‚îÄ‚îÄ -->
        <h2 class="section-title">Installation</h2>

        <div class="code-block"><pre style="margin:0; font-family:inherit; font-size:inherit; line-height:inherit; color:inherit;"><span class="comment"># Install from source</span>
git clone https://github.com/mahyarvaghefi/HUE.git
cd HUE
pip install -e .

<span class="comment"># With community detection (recommended)</span>
pip install -e ".[clustering]"

<span class="comment"># Or install everything</span>
pip install -e ".[all]"</pre></div>

        <div class="callout tip">
            <p class="callout-title">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                Clustering Packages
            </p>
            <p>For best results, install the <code>leidenalg</code> package (uses Surprise optimization from the paper). Without it, HUE falls back to sklearn's spectral clustering, which still works but may produce different community boundaries.</p>
        </div>

        <!-- ‚îÄ‚îÄ Algorithm ‚îÄ‚îÄ -->
        <h2 class="section-title">How the Algorithm Works</h2>

        <p>HUE runs in five steps. The key innovations are in <strong>Steps 3 and 4</strong> ‚Äî a structural similarity that goes beyond simple neighbor overlap, and modularity-based clustering on the resulting weighted graph.</p>

        <div class="steps">
            <div class="step">
                <h4>Select Core Vertices</h4>
                <p>Identify core vertices. In real social networks, these are social media pages sorted by follower count. In synthetic graphs, they can be selected randomly or by degree.</p>
            </div>
            <div class="step">
                <h4>Build Extended Bipartite Graph</h4>
                <p>Provide two separate networks: a bipartite graph (users √ó cores) and a user-to-user graph. Or let HUE extract them from a single graph.</p>
            </div>
            <div class="step">
                <h4>Compute Structural Similarity</h4>
                <p>For every pair of cores, compute the ego's alter-network similarity ‚Äî measuring both shared neighbors <em>and</em> how those neighbors connect to each other. This produces a <strong>weighted graph of cores</strong>.</p>
            </div>
            <div class="step">
                <h4>Modularity-Based Clustering</h4>
                <p>Apply community detection (Louvain/Leiden with Surprise optimization) on the weighted core graph to discover preference clusters.</p>
            </div>
            <div class="step">
                <h4>Embed All Nodes</h4>
                <p>Represent every user by their normalized, weighted connectivity to each cluster. This is the final embedding.</p>
            </div>
        </div>

        <h3 class="sub">Ego's Alter-Network Structural Similarity</h3>

        <p>The core innovation. Given two core vertices A and B, the similarity considers their <strong>ego's alter-networks</strong> ‚Äî the subgraphs formed by their followers and the edges between those followers:</p>

        <div class="formula-card">
            <div class="formula">
                Sim(GÃÉ<sub>A</sub>, GÃÉ<sub>B</sub>) = (|V<sub>common</sub>| + |E<sub>common</sub>|)¬≤ &frasl; ((|V<sub>A</sub>| + |E<sub>A</sub>|) &middot; (|V<sub>B</sub>| + |E<sub>B</sub>|))
            </div>
            <p class="caption">V = vertices (common neighbors), E = edges between those neighbors. Range: [0, 1].</p>
        </div>

        <div class="callout concept">
            <p class="callout-title">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4M12 8h.01"/></svg>
                Why Not Just Count Common Neighbors?
            </p>
            <p>Two pages might share followers who have <strong>nothing to do with each other</strong> ‚Äî that's a weak signal. But if those shared followers also form connections <em>among themselves</em>, that's a strong indicator of genuine shared interest. The edge term |E<sub>common</sub>| captures this second-order structure.</p>
        </div>

        <!-- ‚îÄ‚îÄ Practical Examples ‚îÄ‚îÄ -->
        <h2 class="section-title">Practical Examples</h2>

        <h3 class="sub">Example 1 ‚Äî Basic Community Detection</h3>

        <p>Start with a synthetic graph that has known community structure, then see if HUE can recover it:</p>

        <div class="code-block"><pre style="margin:0; font-family:inherit; font-size:inherit; line-height:inherit; color:inherit;"><span class="comment"># Generate a graph with 4 planted communities (200 nodes each)</span>
import networkx as nx
from hue_embedding import HUE

G = nx.random_partition_graph(
    [200, 200, 200, 200],   <span class="output"># 4 groups of 200 nodes</span>
    p_in=0.4,                <span class="output"># 40% edge probability within groups</span>
    p_out=0.05               <span class="output"># 5% edge probability between groups</span>
)

<span class="comment"># Fit HUE ‚Äî use 15% of nodes as cores</span>
model = HUE(n_cores=0.15, core_selection='random', random_state=42)
embedding = model.fit_transform(G)

print(f"Nodes: {embedding.shape[0]}")       <span class="output"># 800</span>
print(f"Communities found: {model.n_clusters_}")  <span class="output"># ~4</span>
print(f"Embedding columns: {list(embedding.columns)}")
<span class="output"># ['E0', 'E1', 'E2', 'E3']</span></pre></div>

        <div class="visual-example">
            <p class="label">What the embedding looks like</p>
            <div class="code-block" style="margin: 0; padding: 1rem 1.25rem;">
<pre style="margin:0; font-family:inherit; font-size:inherit; line-height:inherit; color:inherit;">print(embedding.head(8))

<span class="output">        E0       E1       E2       E3
0   0.8431   0.0523   0.0512   0.0534
1   0.8107   0.0612   0.0645   0.0636
2   0.0498   0.0501   0.8556   0.0445
3   0.0521   0.8342   0.0589   0.0548
...
</span>
<span class="comment"># Each row sums to 1.0</span>
<span class="comment"># High value in one column = strong membership in that community</span></pre>
            </div>
            <p style="text-align: center; margin-top: 1rem; font-size: 0.88rem; color: var(--text-secondary);">
                Node 0 is <strong style="color: var(--accent);">84%</strong> in community E0 &mdash; Node 2 is <strong style="color: var(--accent);">86%</strong> in community E2
            </p>
        </div>

        <h3 class="sub">Example 2 ‚Äî Inspecting Cluster Composition</h3>

        <p>After fitting, you can examine which core nodes ended up in each cluster:</p>

        <div class="code-block"><pre style="margin:0; font-family:inherit; font-size:inherit; line-height:inherit; color:inherit;"><span class="comment"># See which cores belong to each cluster</span>
for label, members in model.clusters_.items():
    print(f"Cluster {label}: {len(members)} cores ‚Äî {members[:5]}...")

<span class="output"># Cluster 0: 28 cores ‚Äî [12, 45, 78, 134, 189]...
# Cluster 1: 31 cores ‚Äî [203, 256, 289, 312, 367]...
# Cluster 2: 30 cores ‚Äî [401, 445, 478, 512, 534]...
# Cluster 3: 31 cores ‚Äî [601, 634, 678, 712, 756]...</span>

<span class="comment"># Get a dict of {core_node: cluster_label}</span>
labels = model.get_cluster_labels()
print(labels)
<span class="output"># {12: 0, 45: 0, ..., 203: 1, ..., 601: 3, ...}</span></pre></div>

        <h3 class="sub">Example 3 ‚Äî Two Separate Networks (Real-World Workflow)</h3>

        <p>In real social networks, the bipartite structure is already known: users follow social pages, and users are connected to each other. Provide two CSV files and get two outputs ‚Äî page cluster assignments and user embeddings:</p>

        <div class="code-block"><pre style="margin:0; font-family:inherit; font-size:inherit; line-height:inherit; color:inherit;">import warnings
warnings.filterwarnings('ignore')

import numpy as np
import pandas as pd
import networkx as nx
from hue_embedding import HUE

<span class="comment"># 1. Load CSV files</span>
<span class="comment"># bipartite.csv:    columns [Source, Target] ‚Äî Source=user, Target=page</span>
<span class="comment"># user_network.csv: columns [Source, Target] ‚Äî both are users</span>
bipartite_df = pd.read_csv('bipartite.csv')
user_net_df  = pd.read_csv('user_network.csv')

<span class="comment"># 2. Build bipartite graph (users ‚Üí pages)</span>
<span class="comment"># ALL edges are kept ‚Äî every follow relationship is used</span>
bip_graph = nx.from_pandas_edgelist(
    bipartite_df, 'Source', 'Target', create_using=nx.DiGraph())

<span class="comment"># 3. Build user-to-user graph</span>
<span class="comment"># Only MUTUAL (bidirectional) connections are kept.</span>
<span class="comment"># If A follows B but B does not follow A, that edge is removed.</span>
usr_graph = nx.from_pandas_edgelist(
    user_net_df, 'Source', 'Target', create_using=nx.DiGraph())
to_remove = [(u, v) for u, v in usr_graph.edges()
             if not usr_graph.has_edge(v, u)]
usr_graph.remove_edges_from(to_remove)
usr_graph = usr_graph.to_undirected()

<span class="comment"># 4. Identify users and pages, extract adjacency matrices</span>
pages = sorted(set(bipartite_df['Target']))
users = sorted(set(bipartite_df['Source']) - set(pages))
bip_adj = nx.bipartite.biadjacency_matrix(bip_graph, users, pages)
usr_adj = nx.adjacency_matrix(usr_graph, users)

<span class="comment"># 5. Fit HUE (progress is printed automatically)</span>
model = HUE(
    n_clustering_iterations=50,   <span class="comment"># runs of community detection</span>
    partition_method='surprise',   <span class="comment"># or 'modularity'</span>
    n_jobs=2,                      <span class="comment"># parallel workers for similarity</span>
    chunksize=3,                   <span class="comment"># multiprocessing chunk size</span>
    normalize=True,                <span class="comment"># rows sum to 1</span>
    random_state=42
)
embedding = model.fit_from_networks(
    bip_adj, usr_adj,
    user_ids=np.array(users), core_ids=np.array(pages)
)
<span class="output"># [Step 1/5] Validating inputs...
# [Step 2/5] Filtering empty rows/columns...
#   Bipartite: 32000 users x 9847 cores
# [Step 3/5] Computing pairwise similarity for 9847 cores...
#   Computing ego alter-network edge counts...
#   Computing edge similarity matrix...
# [Step 4/5] Clustering cores (surprise, 50 iterations)...
#   Found 128 communities
# [Step 5/5] Computing embeddings...
# Done.</span>

<span class="comment"># 6. Save Output 1: which cluster each page belongs to</span>
cluster_labels = model.get_cluster_labels()
page_clusters = pd.DataFrame([
    {'page': page, 'cluster': label}
    for page, label in cluster_labels.items()
]).sort_values('cluster')
page_clusters.to_csv('page_clusters.csv', index=False)

<span class="comment"># 7. Save Output 2: user embedding vectors</span>
embedding.to_csv('user_embeddings.csv', index=True)
</pre></div>

        <div class="callout tip">
            <p class="callout-title">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M12 2L2 7l10 5 10-5-10-5zM2 17l10 5 10-5M2 12l10 5 10-5"/></svg>
                Choosing Cores &amp; Parameters
            </p>
            <p>In real social networks, <strong>social pages</strong> (high-follower public accounts) are the natural cores ‚Äî they represent clear topics and preferences. Sort pages by follower count and select the top N as your core vertices. When using <code>fit_from_networks</code>, the columns of your bipartite matrix <em>are</em> the cores.</p>
            <p style="margin-top: 0.5rem;">All parameters ‚Äî <code>n_clustering_iterations</code>, <code>partition_method</code>, <code>n_jobs</code>, <code>chunksize</code>, <code>normalize</code> ‚Äî are set on the <code>HUE()</code> constructor and apply to both <code>fit()</code> and <code>fit_from_networks()</code>. Only <code>n_cores</code> and <code>core_selection</code> are ignored by <code>fit_from_networks</code>.</p>
        </div>

        <h3 class="sub">Example 4 ‚Äî Visualizing Core Nodes on the Graph</h3>

        <p>After fitting, you can draw the network and highlight which nodes were selected as cores. Use ForceAtlas2 for a clean community layout:</p>

        <div class="code-block"><pre style="margin:0; font-family:inherit; font-size:inherit; line-height:inherit; color:inherit;">import matplotlib.pyplot as plt
from fa2 import ForceAtlas2

<span class="comment"># Small graph for clear visualization</span>
G = nx.random_partition_graph([40, 40, 40, 40], 0.4, 0.05, seed=42)
model = HUE(n_cores=0.15, core_selection='random', random_state=42)
embedding = model.fit_transform(G)

<span class="comment"># ForceAtlas2 layout ‚Äî reveals community structure</span>
forceatlas2 = ForceAtlas2(strongGravityMode=True, gravity=0.5, verbose=False)
pos = forceatlas2.forceatlas2_networkx_layout(G, pos=None, iterations=500)

<span class="comment"># Draw all nodes (light), then cores on top (bold squares)</span>
fig, ax = plt.subplots(figsize=(10, 10))
nx.draw_networkx_edges(G, pos, alpha=0.15, edge_color='grey', ax=ax)

core_set = set(model.core_nodes_)
regular = [n for n in G.nodes() if n not in core_set]

nx.draw_networkx_nodes(G, pos, nodelist=regular,
                       node_size=80, node_color='#BAE6FD', alpha=0.7, ax=ax)
nx.draw_networkx_nodes(G, pos, nodelist=list(core_set),
                       node_size=140, node_color='#0C4A6E',
                       node_shape='s', edgecolors='white', linewidths=1, ax=ax)

ax.set_title(f'{len(core_set)} Core Nodes (squares) among {G.number_of_nodes()} nodes')
ax.axis('off')
plt.tight_layout()
plt.show()</pre></div>

        <h3 class="sub">Example 5 ‚Äî Visualizing Clustering Results</h3>

        <p>Use the HUE embedding with KMeans to assign every node to a community, then color the graph accordingly:</p>

        <div class="code-block"><pre style="margin:0; font-family:inherit; font-size:inherit; line-height:inherit; color:inherit;">from sklearn.cluster import KMeans

<span class="comment"># Cluster all nodes using HUE embedding</span>
kmeans = KMeans(n_clusters=4, random_state=0, n_init=10)
predicted = kmeans.fit_predict(embedding.values)

<span class="comment"># Color map for communities</span>
colors = ['#0C4A6E', '#DC2626', '#16A34A', '#D97706']

<span class="comment"># Draw the clustered graph (using ForceAtlas2 pos from above)</span>
fig, axes = plt.subplots(1, 2, figsize=(18, 9))

<span class="comment"># Left: ground truth</span>
ground_truth = []
for i, size in enumerate([40, 40, 40, 40]):
    ground_truth.extend([i] * size)
gt_colors = [colors[ground_truth[n]] for n in G.nodes()]

nx.draw_networkx(G, pos, node_color=gt_colors, node_size=80,
                 with_labels=False, edge_color='grey', alpha=0.8,
                 width=0.3, ax=axes[0])
axes[0].set_title('Ground Truth Communities')
axes[0].axis('off')

<span class="comment"># Right: HUE + KMeans</span>
node_colors = [colors[predicted[n]] for n in G.nodes()]
nx.draw_networkx(G, pos, node_color=node_colors, node_size=80,
                 with_labels=False, edge_color='grey', alpha=0.8,
                 width=0.3, ax=axes[1])
axes[1].set_title('HUE + KMeans Predicted')
axes[1].axis('off')

plt.tight_layout()
plt.show()</pre></div>

        <div class="callout warning">
            <p class="callout-title">
                <svg width="16" height="16" fill="none" stroke="currentColor" stroke-width="2" viewBox="0 0 24 24"><path d="M10.29 3.86L1.82 18a2 2 0 001.71 3h16.94a2 2 0 001.71-3L13.71 3.86a2 2 0 00-3.42 0zM12 9v4M12 17h.01"/></svg>
                Directed vs. Undirected Edges
            </p>
            <p><strong>Bipartite network:</strong> All edges are kept ‚Äî every user‚Üípage follow is used (directed).<br>
            <strong>User-to-user network:</strong> Only <strong>mutual</strong> (bidirectional) connections are kept. If A follows B but B does not follow A, that edge is removed. This ensures only genuine friendships are used.<br>
            <strong>Single-graph mode:</strong> HUE expects an undirected graph. Convert directed graphs with <code>G = G.to_undirected()</code>.</p>
        </div>

        <!-- ‚îÄ‚îÄ API Reference ‚îÄ‚îÄ -->
        <h2 class="section-title">API Reference</h2>

        <h3 class="sub">Constructor</h3>

        <div class="code-block" style="margin-bottom: 0.5rem;"><pre style="margin:0; font-family:inherit; font-size:inherit; line-height:inherit; color:inherit;">from hue_embedding import HUE
model = HUE(n_cores=0.15, core_selection='random',
            n_clustering_iterations=50, partition_method='surprise',
            n_jobs=2, normalize=True, random_state=None)</pre></div>

        <div class="table-wrapper">
            <table>
                <thead>
                    <tr><th>Parameter</th><th>Type</th><th>Default</th><th>Description</th></tr>
                </thead>
                <tbody>
                    <tr><td><code>n_cores</code></td><td>int&nbsp;/&nbsp;float</td><td><code>0.15</code></td><td>Number of cores (int ‚â• 1) or fraction of nodes (float in 0‚Äì1). Ignored by <code>fit_from_networks</code>.</td></tr>
                    <tr><td><code>core_selection</code></td><td>str</td><td><code>'random'</code></td><td><code>'random'</code>, <code>'degree'</code>, or <code>'predefined'</code>. Ignored by <code>fit_from_networks</code>.</td></tr>
                    <tr><td><code>n_clustering_iterations</code></td><td>int</td><td><code>50</code></td><td>Runs of community detection (higher = more stable)</td></tr>
                    <tr><td><code>partition_method</code></td><td>str</td><td><code>'surprise'</code></td><td><code>'surprise'</code> (SurpriseVertexPartition) or <code>'modularity'</code> (ModularityVertexPartition)</td></tr>
                    <tr><td><code>n_jobs</code></td><td>int</td><td><code>2</code></td><td>Parallel workers for similarity computation</td></tr>
                    <tr><td><code>normalize</code></td><td>bool</td><td><code>True</code></td><td>Normalize rows to sum to 1 (proportional membership)</td></tr>
                    <tr><td><code>verbose</code></td><td>bool</td><td><code>True</code></td><td>Print progress messages during fitting</td></tr>
                    <tr><td><code>random_state</code></td><td>int / None</td><td><code>None</code></td><td>Seed for reproducibility</td></tr>
                </tbody>
            </table>
        </div>

        <h3 class="sub">Methods</h3>

        <div class="table-wrapper">
            <table>
                <thead>
                    <tr><th>Method</th><th>Returns</th><th>Description</th></tr>
                </thead>
                <tbody>
                    <tr><td><code>fit(G, core_nodes=None)</code></td><td>self</td><td>Fit from a single NetworkX graph</td></tr>
                    <tr><td><code>transform(G=None)</code></td><td>DataFrame</td><td>Return embedding; if G provided, embed new graph using fitted clusters</td></tr>
                    <tr><td><code>fit_transform(G, core_nodes=None)</code></td><td>DataFrame</td><td>Fit and return embedding in one call</td></tr>
                    <tr><td><code>fit_from_networks(bip_adj, usr_adj, ...)</code></td><td>DataFrame</td><td>Fit from two separate adjacency matrices (bipartite + user network)</td></tr>
                    <tr><td><code>get_cluster_labels()</code></td><td>dict</td><td>Returns <code>{core_node: cluster_label}</code> mapping</td></tr>
                </tbody>
            </table>
        </div>

        <h3 class="sub">Attributes (available after fitting)</h3>

        <div class="table-wrapper">
            <table>
                <thead>
                    <tr><th>Attribute</th><th>Type</th><th>Description</th></tr>
                </thead>
                <tbody>
                    <tr><td><code>core_nodes_</code></td><td>ndarray</td><td>Selected core vertex IDs</td></tr>
                    <tr><td><code>similarity_matrix_</code></td><td>csr_matrix</td><td>Weighted core-to-core similarity graph</td></tr>
                    <tr><td><code>clusters_</code></td><td>dict</td><td><code>{label: [core_ids]}</code> for each discovered cluster</td></tr>
                    <tr><td><code>n_clusters_</code></td><td>int</td><td>Number of communities discovered</td></tr>
                    <tr><td><code>embedding_</code></td><td>DataFrame</td><td>Full embedding ‚Äî shape <code>(n_nodes, n_clusters)</code></td></tr>
                </tbody>
            </table>
        </div>

        <!-- ‚îÄ‚îÄ Citation ‚îÄ‚îÄ -->
        <h2 class="section-title">Citation</h2>

        <p>If you use HUE in your research, please cite:</p>

        <div class="citation-block">
            Vaghefi, M. S., &amp; Nazareth, D. L. (2021). Mining Online Social Networks: Deriving User Preferences through Node Embedding. <strong>Journal of the Association for Information Systems, 22</strong>(6), 1625‚Äì1658.
            <a href="https://doi.org/10.17705/1jais.00711">doi:&nbsp;10.17705/1jais.00711</a>
        </div>

        <div class="bibtex-block">@article{vaghefi2021mining,
  title     = {Mining Online Social Networks: Deriving User
               Preferences through Node Embedding},
  author    = {Vaghefi, Mahyar S. and Nazareth, Derek L.},
  journal   = {Journal of the Association for Information Systems},
  volume    = {22},
  number    = {6},
  pages     = {1625--1658},
  year      = {2021},
  doi       = {10.17705/1jais.00711}
}</div>

        <!-- ‚îÄ‚îÄ Takeaways ‚îÄ‚îÄ -->
        <div class="takeaways">
            <h3>Key Takeaways</h3>
            <div class="takeaway-item"><span class="check">&#10003;</span><span><strong>Interpretable embeddings</strong> ‚Äî each dimension maps to a real community of interest, not a latent factor.</span></div>
            <div class="takeaway-item"><span class="check">&#10003;</span><span><strong>Two input modes</strong> ‚Äî provide two separate networks with <code>fit_from_networks()</code> (recommended), or a single graph with <code>fit()</code>.</span></div>
            <div class="takeaway-item"><span class="check">&#10003;</span><span><strong>Social pages as cores</strong> ‚Äî high-follower accounts make the best cores and the most interpretable clusters.</span></div>
            <div class="takeaway-item"><span class="check">&#10003;</span><span><strong>Visualize cores &amp; clusters</strong> ‚Äî draw selected cores on the graph, then color nodes by community assignment.</span></div>
            <div class="takeaway-item"><span class="check">&#10003;</span><span><strong>Output is a DataFrame</strong> ‚Äî rows are nodes, columns are communities, values sum to 1.</span></div>
            <div class="takeaway-item"><span class="check" style="color: #FDE68A;">!</span><span><strong>Remember:</strong> For single-graph mode, HUE needs an undirected graph. Convert with <code>G.to_undirected()</code>.</span></div>
        </div>

        <!-- ‚îÄ‚îÄ Cheat Sheet ‚îÄ‚îÄ -->
        <h2 class="section-title">Code Cheat Sheet</h2>

        <div class="code-block"><pre style="margin:0; font-family:inherit; font-size:inherit; line-height:inherit; color:inherit;"><span class="comment"># Install</span>
pip install -e ".[clustering]"

<span class="comment"># ‚îÄ‚îÄ Option A: Two separate networks (recommended for real data) ‚îÄ‚îÄ</span>
import numpy as np, pandas as pd, networkx as nx
from hue_embedding import HUE

bipartite_df = pd.read_csv('bipartite.csv')       <span class="output"># [Source, Target]</span>
user_net_df  = pd.read_csv('user_network.csv')     <span class="output"># [Source, Target]</span>

bip_graph = nx.from_pandas_edgelist(bipartite_df, 'Source', 'Target', create_using=nx.DiGraph())
usr_graph = nx.from_pandas_edgelist(user_net_df, 'Source', 'Target')

pages = sorted(set(bipartite_df['Target']))
users = sorted(set(bipartite_df['Source']) - set(pages))
bip_adj = nx.bipartite.biadjacency_matrix(bip_graph, users, pages)
usr_adj = nx.adjacency_matrix(usr_graph, users)

model = HUE(
    n_clustering_iterations=50,
    partition_method='surprise',
    n_jobs=2, chunksize=3,
    normalize=True, random_state=42
)
embedding = model.fit_from_networks(
    bip_adj, usr_adj,
    user_ids=np.array(users), core_ids=np.array(pages)
)

<span class="comment"># Save outputs</span>
pd.DataFrame([{'page': p, 'cluster': c}
              for p, c in model.get_cluster_labels().items()
             ]).to_csv('page_clusters.csv', index=False)
embedding.to_csv('user_embeddings.csv', index=True)

<span class="comment"># ‚îÄ‚îÄ Option B: Single graph (synthetic data, exploration) ‚îÄ‚îÄ</span>
import networkx as nx

model = HUE(n_cores=0.15, random_state=42)
embedding = model.fit_transform(G)         <span class="output"># ‚Üí DataFrame</span>

<span class="comment"># Inspect results</span>
model.n_clusters_                           <span class="output"># Number of communities</span>
model.clusters_                             <span class="output"># {label: [core_ids]}</span>
model.get_cluster_labels()                  <span class="output"># {core: label}</span>

<span class="comment"># Visualize cores on the graph</span>
from fa2 import ForceAtlas2
fa2 = ForceAtlas2(strongGravityMode=True, gravity=0.5, verbose=False)
pos = fa2.forceatlas2_networkx_layout(G, pos=None, iterations=500)
core_set = set(model.core_nodes_)
nx.draw_networkx_nodes(G, pos, nodelist=list(core_set),
                       node_shape='s', node_color='#0C4A6E')

<span class="comment"># Cluster all nodes and visualize</span>
from sklearn.cluster import KMeans
labels = KMeans(n_clusters=4).fit_predict(embedding)
nx.draw_networkx_nodes(G, pos, node_color=labels, cmap=plt.cm.Set1)

<span class="comment"># User's dominant community</span>
embedding.iloc[42].idxmax()                 <span class="output"># ‚Üí 'E0'</span></pre></div>

        <!-- ‚îÄ‚îÄ Footer ‚îÄ‚îÄ -->
        <div class="guide-footer">
            <p><strong>HUE</strong> &middot; Homophily-based User Embedding</p>
            <p style="margin-top: 0.4rem;">Dr. Mahyar S. Vaghefi &amp; Dr. Derek L. Nazareth</p>
            <p style="margin-top: 0.75rem;"><a href="../index.html">&larr; Back to mahyarvaghefi.github.io</a></p>
        </div>
    </div>
</body>
</html>
